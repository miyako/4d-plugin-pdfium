/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-pdfium.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : pdfium
 #	author : miyako
 #	2025/06/17
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-pdfium.h"

#pragma mark -

static void OnStart() {
    FPDF_InitLibrary();
}

static void OnExit() {
    FPDF_DestroyLibrary();
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStart();
                break;
                
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                OnExit();
                break;
                
			// --- pdfium
            
			case 1 :
				pdf_to_image(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static bool _object_to_path(PA_ObjectRef f, std::string& path, int type) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(type, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = std::string((const char *)u8.c_str(), u8.size());
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static bool file_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1566 /*4D.File*/);
}

#pragma mark -

// Memory write callback
static void write_to_buffer(void* context, void* data, int size) {
    std::vector<unsigned char>* buf = reinterpret_cast<std::vector<unsigned char>*>(context);
    unsigned char* bytes = static_cast<unsigned char*>(data);
    buf->insert(buf->end(), bytes, bytes + size);
}

void pdf_to_image(PA_PluginParameters params) {

    PA_ObjectRef inputFile = PA_GetObjectParameter(params, 1);
    std::string inputFilePath;
    if(inputFile) {
        file_object_to_path(inputFile, inputFilePath);
    }
    
//    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
//    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    float dpi = 72.0f;
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    
    if(options != NULL) {
        if(ob_is_defined(options, L"dpi")) {
            dpi = ob_get_n(options, L"dpi");
        }
    }
    
    float scale = dpi / 72.0f;
    
    PA_CollectionRef images = PA_CreateCollection();
    
    if(inputFilePath.length() != 0) {
        FPDF_DOCUMENT doc = FPDF_LoadDocument(inputFilePath.c_str(), nullptr);
        if(doc){
            auto startTime = std::chrono::high_resolution_clock::now();//time(0);
            int count = FPDF_GetPageCount(doc);
            for(auto i = 0; i < count; ++i) {
                FPDF_PAGE page = FPDF_LoadPage(doc, i);
                if(page) {
                    float page_width_pt = FPDF_GetPageWidthF(page);
                    float page_height_pt = FPDF_GetPageHeightF(page);
                    int width_px = (int)(page_width_pt * scale);
                    int height_px = (int)(page_height_pt * scale);
                    FPDF_BITMAP bitmap = FPDFBitmap_Create(width_px, height_px, 1);
                    FPDFBitmap_FillRect(bitmap, 0, 0, width_px, height_px, 0xFFFFFFFF);
                    FPDF_RenderPageBitmap(bitmap, page, 0, 0, width_px, height_px, 0, 0);
                    unsigned char* buffer = static_cast<unsigned char*>(FPDFBitmap_GetBuffer(bitmap));
                    int stride = FPDFBitmap_GetStride(bitmap);
                    // Convert BGRA -> RGBA for PNG output
                    std::vector<unsigned char> rgba(width_px * height_px * 4);
                    for (int y = 0; y < height_px; ++y) {
                        
                        auto now = std::chrono::high_resolution_clock::now();//time(0);
                        auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                        
                        if(elapsedTime > 100)
                        {
                            startTime = now;
                            PA_YieldAbsolute();
                        }
                        
                        for (int x = 0; x < width_px; ++x) {
                            int i = y * stride + x * 4;
                            int j = (y * width_px + x) * 4;
                            rgba[j + 0] = buffer[i + 2]; // R
                            rgba[j + 1] = buffer[i + 1]; // G
                            rgba[j + 2] = buffer[i + 0]; // B
                            rgba[j + 3] = buffer[i + 3]; // A
                        }
                    }
                 
                    // In-memory PNG buffer
                    std::vector<unsigned char> png_data;
                    stbi_write_png_to_func(write_to_buffer,
                                           &png_data,
                                           width_px,
                                           height_px,
                                           4,
                                           rgba.data(),
                                           width_px * 4);

                    PA_Variable v = PA_CreateVariable(eVK_Picture);
                    PA_Picture image = PA_CreatePicture((void *)&png_data[0], (PA_long32)png_data.size());
                    PA_SetPictureVariable(&v, image);
                    PA_SetCollectionElement(images, PA_GetCollectionLength(images), v);
                    PA_ClearVariable(&v);
                    
                    FPDFBitmap_Destroy(bitmap);
                    FPDF_ClosePage(page);

                }else{
                    PA_Variable v = PA_CreateVariable(eVK_Null);
                    PA_SetCollectionElement(images, PA_GetCollectionLength(images), v);
                    PA_ClearVariable(&v);
                }
            }
            FPDF_CloseDocument(doc);
        }//doc
    }
    
    PA_ReturnCollection(params, images);
}

